<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor 16 de Julio - 3D Builder</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
        }

        canvas {
            display: block;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            width: 250px;
            user-select: none;
        }

        h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            color: #333;
        }

        p {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button.secondary {
            background: #6c757d;
        }

        #stats {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }

        #json-output {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            border-radius: 5px;
            display: none;
            overflow-y: auto;
        }
    </style>
</head>

<body>

    <div id="ui-panel">
        <h2>Feria 16 de Julio 3D</h2>
        <p>Arrastra para mover | Rueda para Zoom<br>Clic para colocar puesto</p>
        <div class="btn-group">
            <button onclick="window.setMode('build')">Modo Construcción</button>
            <button class="secondary" onclick="window.setMode('delete')">Modo Borrar (Alt+Clic)</button>
            <button style="background: #28a745;" onclick="window.exportMap()">Exportar Datos JSON</button>
        </div>
    </div>

    <div id="stats">Puestos colocados: <span id="count">0</span></div>
    <div id="json-output"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuración Inicial ---
        let mode = 'build';
        const placedObjects = [];
        const mapData = [];

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd0d0d0);

        // Cámara Ortográfica: Configuración "Cenital Inclinada"
        const aspect = window.innerWidth / window.innerHeight;
        const d = 10;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

        // Posición inclinada estilo Overcrowded
        camera.position.set(0, 40, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Iluminación ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 20, 10);
        scene.add(dirLight);

        // --- Suelo y Rejilla ---
        // Ajustamos la rejilla para que las líneas estén en los bordes y el centro de la celda sea el objetivo
        const gridSize = 100;
        const gridHelper = new THREE.GridHelper(gridSize, gridSize, 0x888888, 0xaaaaaa);
        scene.add(gridHelper);

        const planeGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
        const collisionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        collisionPlane.rotation.x = -Math.PI / 2;
        scene.add(collisionPlane);

        // Cursor indicador (Ghost) - Ahora se posiciona en el centro de la celda
        const ghostGeo = new THREE.BoxGeometry(1, 0.05, 1);
        const ghostMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
        const ghostMesh = new THREE.Mesh(ghostGeo, ghostMat);
        scene.add(ghostMesh);

        // --- Interacción ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isMouseDown = false;
        let prevMousePos = { x: 0, y: 0 };

        window.setMode = (m) => {
            mode = m;
            ghostMat.color.set(m === 'build' ? 0x00ff00 : 0xff0000);
        };

        // Función para calcular el centro de la celda (Snap to Center)
        const getGridCenter = (pos) => {
            return {
                x: Math.floor(pos.x) + 0.5,
                z: Math.floor(pos.z) + 0.5
            };
        };

        const onMouseMove = (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (isMouseDown) {
                const deltaX = event.clientX - prevMousePos.x;
                const deltaY = event.clientY - prevMousePos.y;
                const scale = (d * 2) / (window.innerHeight * camera.zoom);

                camera.position.x -= deltaX * scale;
                camera.position.z -= deltaY * scale;

                prevMousePos = { x: event.clientX, y: event.clientY };
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(collisionPlane);
            if (intersects.length > 0) {
                const center = getGridCenter(intersects[0].point);
                ghostMesh.position.set(center.x, 0.01, center.z);
            }
        };

        const onMouseDown = (event) => {
            if (event.button === 0) {
                isMouseDown = true;
                prevMousePos = { x: event.clientX, y: event.clientY };

                if (!event.altKey && mode === 'build') placeObject();
                else if (event.altKey || mode === 'delete') deleteObject();
            }
        };

        const onMouseUp = () => isMouseDown = false;

        const onWheel = (event) => {
            camera.zoom = Math.max(0.2, Math.min(10, camera.zoom - event.deltaY * 0.001));
            camera.updateProjectionMatrix();
        };

        const placeObject = () => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(collisionPlane);
            if (intersects.length > 0) {
                const center = getGridCenter(intersects[0].point);

                if (mapData.some(d => d.x === center.x && d.z === center.z)) return;

                const geometry = new THREE.BoxGeometry(0.9, 0.8, 0.9);
                const material = new THREE.MeshStandardMaterial({
                    color: Math.random() > 0.5 ? 0x3355ff : 0xff3333,
                    roughness: 0.7
                });
                const box = new THREE.Mesh(geometry, material);

                // Posicionamiento centrado en la celda
                box.position.set(center.x, 0.4, center.z);
                scene.add(box);

                placedObjects.push(box);
                mapData.push({ x: center.x, z: center.z, type: 'puesto' });
                document.getElementById('count').innerText = mapData.length;
            }
        };

        const deleteObject = () => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(placedObjects);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                scene.remove(obj);
                const index = placedObjects.indexOf(obj);
                placedObjects.splice(index, 1);
                mapData.splice(index, 1);
                document.getElementById('count').innerText = mapData.length;
            }
        };

        window.exportMap = () => {
            const output = document.getElementById('json-output');
            output.style.display = 'block';
            output.innerText = JSON.stringify(mapData, null, 2);
        };

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('wheel', onWheel, { passive: false });
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const animate = () => {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };
        animate();
    </script>
</body>

</html>